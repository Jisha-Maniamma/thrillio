#Implementing managers

* Managers have business logic
We need to write some methods that will instantiate the entities we just created.
The methods we write will be used in the data store which will be written later.

*We will write the User manager and Bookmark manager.
User manager will have business logic related to users. While Bookmark manager will do the same for Bookmarks.

Manager classes are stateless and maintain no instance variables. We can maintain them as static utility classes.
However for managers it is recommended to instead create just one single instance of each of the manager classes. The reason is that managers can need to implement interfaces and i\
n those instances, you cannot use a static utility class as static methods in that class cannot hide or overwite instance methods in an interface. So the recommended way is to crea\
te a single instance of the manager class.
This is achieved by using a design pattern called a Singleton pattern

##Singleton pattern

Is a design pattern that ensures that only one object is created and no more. Singleton pattern also provides a global point to access the object. So manager classes are basically \
Singletons
One way to implement it is to:
1.  create a private static instance variable of the class
2.  create a public static getInstance() method which returns a reference to the above instance

One we get the instance, we can run all non-static methods inherited from interfaces and can even override them.

#Constant exporting classes
* These are classes that exist only for defining constants eg fields like genre or gender have a range of values. The same is true for the userType field. The constant exporting cl\
asses will be useful when we have to check if a field has a particular value.

#Implementing Data store
Creating our "database" in a data store (a class called DataStore)

#Implementing Data Access Objects (DAOs)
Code that fetches data from database or other data stores. In our case, since we do not have a database, our methods will be calling on the getter methods in the DataStore class
In Model-View-Controller architecture, controllers will invoke managers and managers will invoke data access objects. 
This was implemented by:
 1. creating unique DAOs for the two types of classes in our system -> Users & Bookmarks (a UserDao and a BookmarkDao). 
 	- These DAO classes will contain methods for interacting with the data layer
 	- inside these DAOs, we add getter methods for the types of objects they request. eg in UserDao, we have a getUsers() method
 2. adding getter methods inside the DAOs
 3. now that the DAOs are set, we now look at updating our managers. 
 The controller will in the future be requesting data through the managers so lets make methods in managers for handling such requests.
  create methods in our managers for interacting with the DAOs.
  
  # Project Status And Launching
  So far we have implemented the model and the datastore. We are yet to implement the view and the controller. 
  To launch our application, we need to write a separate program that would:
  1. load our data - all our entities -> users & bookmarks
  2. invoke the different steps in the controller and view.
  
  Now we focus on writing our launcher program and use it to load the data and see if everything we have written is working so far.
  Since this program is a launcher, it must have the main() method which is the entry point for running the program.
  The Launcher class will run scripts to load the data store then print out the contents to the console. In printing the objects,
  there is an easy way to overide the inherited toString() method using Eclipse: Source->Generate toString...